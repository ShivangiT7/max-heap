<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>A Study In Max Heap by robin-thomas</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>A Study In Max Heap</h1>
          <h2></h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/robin-thomas/max-heap/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/robin-thomas/max-heap/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/robin-thomas/max-heap" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="what-is-a-max-heap-" class="anchor" href="#what-is-a-max-heap-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is a Max Heap ?<br><br>
</h1>

<h3>
<a id="max-heap-is-data-structure-that-satisfies-two-properties-" class="anchor" href="#max-heap-is-data-structure-that-satisfies-two-properties-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><em>Max heap is data structure that satisfies two properties :</em>
</h3>

<h3>
<a id="shape-property" class="anchor" href="#shape-property" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><em>Shape property</em>
</h3>

<p><em>It states that max heap is a complete binary tree, which is a binary tree that is filled at all levels, except perhaps the last level, which is filled from left to right.</em> </p>

<p>We can infer a couple of things from the above statement. Firstly, the leaf nodes of the tree will be in last level or the level above it. Secondly, in all levels except perhaps the last level, every parent node should exactly have two children. And finally, no right sibilng can exist without its left sibling.</p>

<h3>
<a id="heap-property" class="anchor" href="#heap-property" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><em>Heap property</em>
</h3>

<p><em>It states that the value of the parent node is always greater than or equal to that of its children.</em></p>

<p>It means that the maximum value in the heap shall occur at the root node, and the minimum value in the heap shall occur at any of the leaf nodes. Do note that heap property doesn't mention any relationship between the left and right sibling of a node. The left sibling may have a value greater than the right sibling, or it may be the other way around. As long as every parent has a value greater than its siblings, heap property is satisifed.</p>

<p>If any of the above two property is violated, its not a max heap.</p>

<hr>

<h1>
<a id="various-heap-operations" class="anchor" href="#various-heap-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Various Heap Operations<br><br>
</h1>

<p>Various operations like insertion and deletion of a node can be done efficiently using a max heap structure. But before we get into that, lets first start with how to create a max heap structure. Given below is the C code for the same.</p>

<pre><code>#define LCHILD(x) 2 * x + 1
#define RCHILD(x) 2 * x + 2
#define PARENT(x) (x - 1) / 2

typedef struct node {
    int data ;
} node ;

typedef struct maxHeap {
    int size ;
    node *elem ;
} maxHeap ;
</code></pre>

<p>In the above code, we are creating two structures, one to represent a node and other to represent the entire max heap. The node structure has only a single member to hold the data. The maxHeap structure has two members - one to hold the total size of the max heap at any time, and the other is a pointer to the heap.</p>

<p>Though the heap can be implemented using various child and parent pointers, its easier to use a dynamic array. Since in C array indexing begins at index 0, given a node at index i, its left child shall be at (2 * i + 1) and right child shall be at (2 * i + 2). Also, given a node at index i, its parent node shall be at index x / 2.</p>

<p>Since the max heap can be growing dynamically, we shall be using a dynamic array which shall grow and shrink its size as required.</p>

<p>We also need an initializor function that shall initialize the data members of the max heap with default values.</p>

<pre><code>maxHeap initMaxHeap(int size) {
    maxHeap hp ;
    hp.size = 0 ;
    return hp ;
}
</code></pre>

<p>We are creating a variale of type maxHeap and setting its size variable to 0, and returning the maxHeap variable back. So in the main function, you can have something like,</p>

<pre><code>maxHeap hp = initMaxHeap() ;
</code></pre>

<h3>
<a id="insertion" class="anchor" href="#insertion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Insertion</h3>

<p>At best case, it takes only O(1) time to insert a node into max heap. But at worst case, the new node may be greater than all nodes in the heap, that it needs to be compared with log(n) elements at most to be put into the root node position. So insertion operation is normally considered as an O(logn) operation. Given below is the C code for the same.</p>

<pre><code>void insertNode(maxHeap *hp, int data) {
    // allocating space
    if(hp-&gt;size) {
        hp-&gt;elem = realloc(hp-&gt;elem, (size + 1) * sizeof(node)) ;
    } else {
        hp-&gt;elem = malloc(sizeof(node)) ;
    }

    // initializing the node with value
    node nd ;
    nd.data = data ;

    // Positioning the node at the right position in the max heap
    int i = (hp-&gt;size)++ ;
    while(i &amp;&amp; nd.data &gt; hp-&gt;elem[PARENT(i)].data) {
        hp-&gt;elem[i] = hp-&gt;elem[PARENT(i)] ;
        i = PARENT(i) ;
    }
    hp-&gt;elem[i] = nd ;
}
</code></pre>

<p>In first part of insertNode() function, we allocate space for one node. On its first iteration, size variable is zero, and hence call to malloc() function is performed. Henceforth, all calls shall go to realloc() function which shall increase the memory to allocate one more node in the max heap.</p>

<p>In second part of insertNode() function, we simply create a node variable and initialize it with data that we need to store in the node.</p>

<p>In last part of insertNode() function, we shall find the correct position for the new node in max heap structure. We consider the new memory space created. We shall compare value of last node with the new node value. If its less, we shall move it to the new memory location. We shall now check its parent node, and compare it with new node. If its less, we shall move it to old position of last node. It will continue until we find a node which has value higher than the new node, and place the new node as a child node of that node.</p>

<h3>
<a id="deletion" class="anchor" href="#deletion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deletion</h3>

<p>Deletion operation is quite different from insertion operation. In each deletion operation, we shall delete the maximum element from max heap, ie, we shall always delete the root node in each deletion operation, and place the last node in root node position. Since we are placing a leaf node in root node, its guaranteed that heap property shall be violated. We shall then call a special function called heapify() function recursively to make sure that heap property is satisfied.</p>

<pre><code>void swap(node *n1, node *n2) {
    node temp = *n1 ;
    *n1 = *n2 ;
    *n2 = temp ;
}
</code></pre>

<pre><code>void heapify(maxHeap *hp, int i) {
    int largest = (LCHILD(i) &lt; hp-&gt;size &amp;&amp; hp-&gt;elem[LCHILD(i)].data &gt; hp-&gt;elem[i].data) ? LCHILD(i) : i ;
    if(RCHILD(i) &lt; hp-&gt;size &amp;&amp; hp-&gt;elem[RCHILD(i)].data &gt; hp-&gt;elem[largest].data) {
        largest = RCHILD(i) ;
    }
    if(largest != i) {
        swap(&amp;(hp-&gt;elem[i]), &amp;(hp-&gt;elem[largest])) ;
        heapify(hp, largest) ;
    }
}
</code></pre>

<pre><code>void deleteNode(maxHeap *hp) {
    if(hp-&gt;size) {
        printf("Deleting node %d\n\n", hp-&gt;elem[0].data) ;
        hp-&gt;elem[0] = hp-&gt;elem[--(hp-&gt;size)] ;
        hp-&gt;elem = realloc(hp-&gt;elem, hp-&gt;size * sizeof(node)) ;
        heapify(hp, 0) ;
    } else {
        printf("\nMax Heap is empty!\n") ;
        free(hp-&gt;elem) ;
    }
}
</code></pre>

<p>In deleteNode() function, last node is placed at root node position, heap size decremented by 1, and memory of max heap reduced by one node. Heapify() function shall then be called.</p>

<p>In heapify() function, given a node at index i, we shall compare all the three nodes (parent, left and right child), and find the largest node of the three. If its not the parent node, then heap property is violated. Swap parent node with largest node, and call heapify() function until heap property is satisfied.</p>

<h3>
<a id="buildmaxheap" class="anchor" href="#buildmaxheap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BuildMaxHeap</h3>

<p>Given an array of n numbers, we can call the insertNode() function n times to create the max heap. Since each call to insertNode() can take upto O(logn) time, we need a maximum of O(nlogn) time to create the entire max heap. But instead of following such an approach, we can follow a relatively better buildMaxHeap() function that requires only O(n) time.</p>

<pre><code>void buildMaxHeap(maxHeap *hp, int *arr, int size) {
    int i ;

    // Insertion into the heap without violating the shape property
    for(i = 0; i &lt; size; i++) {
        if(hp-&gt;size) {
            hp-&gt;elem = realloc(hp-&gt;elem, (hp-&gt;size + 1) * sizeof(node)) ;
        } else {
            hp-&gt;elem = malloc(sizeof(node)) ;
        }
        node nd ;
        nd.data = arr[i] ;
        hp-&gt;elem[(hp-&gt;size)++] = nd ;
    }

    // Making sure that heap property is also satisfied
    for(i = (hp-&gt;size - 1) / 2; i &gt;= 0; i--) {
        heapify(hp, i) ;
    }
}
</code></pre>

<p>In first step, we insert all elements from the array into the max heap without bothering about heap property. Since the heap is built using array structure, shape property is never violated.</p>

<p>In last step, we shall determine the last parent in the heap and call heapify() function on that parent node, until heap property is satisfied for that node. We shall then work back by calling heapify() function on each of those parent nodes, until we reach root node, by which time, heap property shall be satisfied.</p>

<h3>
<a id="traversal" class="anchor" href="#traversal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Traversal</h3>

<p>There are mainly two types of traversals possible on a max heap - depth first traversal and breadth first (level order) traversal. </p>

<p>In depth first traversal, we visit the nodes depth-wise, meaning that we go deeper and deeper into childrens of a left sibling before covering the right sibling. There are mainly three depth first traversals possible - inorder, preorder and postorder traversal.</p>

<h4>
<a id="inorder-traversal" class="anchor" href="#inorder-traversal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inorder Traversal</h4>

<pre><code>void inorderTraversal(maxHeap *hp, int i) {
    if(LCHILD(i) &lt; hp-&gt;size) {
        inorderTraversal(hp, LCHILD(i)) ;
    }
    printf("%d ", hp-&gt;elem[i].data) ;
    if(RCHILD(i) &lt; hp-&gt;size) {
        inorderTraversal(hp, RCHILD(i)) ;
    }
}
</code></pre>

<p>In the above function, we check whether left child of a node at index i exists in the heap. If yes, we call the inorderTraveral() function on the left child. We now display value of the node at index i. Then we check whether right child of a node at index i exists in the heap. If yes, we call inorderTraversal() on the right child. This shall continue until we traverse the whole max heap.</p>

<h4>
<a id="preorder-traversal" class="anchor" href="#preorder-traversal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Preorder Traversal</h4>

<pre><code>void preorderTraversal(maxHeap *hp, int i) {
    if(LCHILD(i) &lt; hp-&gt;size) {
        preorderTraversal(hp, LCHILD(i)) ;
    }
    if(RCHILD(i) &lt; hp-&gt;size) {
        preorderTraversal(hp, RCHILD(i)) ;
    }
    printf("%d ", hp-&gt;elem[i].data) ;
}
</code></pre>

<p>In the above function, we check whether left child of the node at index i exists. If yes, we call preorderTraversal() on the left child. We then check whether right of the node exists. If yes, we call preorderTraversal() on the right child. we then display the value of the node at index i. We can see that code for preorderTraversal() and inorderTraversal() are quite similar and shall be similar to postorderTraversal() function. The only difference is the order in which the recursive functions are called.</p>

<h4>
<a id="postorder-traversal" class="anchor" href="#postorder-traversal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Postorder Traversal</h4>

<pre><code>void postorderTraversal(maxHeap *hp, int i) {
    printf("%d ", hp-&gt;elem[i].data) ;
    if(LCHILD(i) &lt; hp-&gt;size) {
        postOrderTraversal(hp, LCHILD(i)) ;
    }
    if(RCHILD(i) &lt; hp-&gt;size) {
        postorderTraversal(hp, RCHILD(i)) ;
    }
}
</code></pre>

<p>In postOrderTraversal() function, we display the value of the node at index 1, and recursively call the function, first on the left child and then on the right child, until we traverse the whole max heap.</p>

<h4>
<a id="levelorder-traversal" class="anchor" href="#levelorder-traversal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Levelorder Traversal</h4>

<pre><code>void levelOrderTraversal(maxHeap *hp) {
    int i ;
    for(i = 0; i &lt; hp-&gt;size; i++) {
        printf("%d ", hp-&gt;elem[i].data) ;
    }
}
</code></pre>

<p>Implementing level order traversal is quite simple, as we are using the array implementation. All we need to do is to traverse through the whole array from index 0 to (hp-&gt;size - 1) to get the level order traversal.</p>

<hr>

<h1>
<a id="applications-of-max-heap" class="anchor" href="#applications-of-max-heap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Applications of Max Heap<br><br>
</h1>

<p>As you are already aware by now, when we delete an element from the max heap, we always get the maximum valued node from the max heap, which means that we can access the maximum valued node in O(1) time. So if you need a quick access to the largest value element, you can go for max heap implementation.</p>

<p>Max heaps can be used to implement priority queues. In a priority queue, rather than using the value of a node, we are using priority of the node to position it in the max heap. Priority queues are used heavily in job schedulers.</p>
        </section>

        <footer>
          A Study In Max Heap is maintained by <a href="https://github.com/robin-thomas">robin-thomas</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
