{"name":"A Study In Max Heap","tagline":"","body":"# What is a Max Heap ?<br /><br />\r\n\r\n###_Max heap is data structure that satisfies two properties :_\r\n\r\n###_Shape property_\r\n_It states that max heap is a complete binary tree, which is a binary tree that is filled at all levels, except perhaps the last level, which is filled from left to right._ \r\n\r\nWe can infer a couple of things from the above statement. Firstly, the leaf nodes of the tree will be in last level or the level above it. Secondly, in all levels except perhaps the last level, every parent node should exactly have two children. And finally, no right sibilng can exist without its left sibling.\r\n\r\n###_Heap property_\r\n_It states that the value of the parent node is always greater than or equal to that of its children._\r\n\r\nIt means that the maximum value in the heap shall occur at the root node, and the minimum value in the heap shall occur at any of the leaf nodes. Do note that heap property doesn't mention any relationship between the left and right sibling of a node. The left sibling may have a value greater than the right sibling, or it may be the other way around. As long as every parent has a value greater than its siblings, heap property is satisifed.\r\n\r\nIf any of the above two property is violated, its not a max heap.\r\n\r\n\r\n***\r\n\r\n# Various Heap Operations<br /><br />\r\n\r\nVarious operations like insertion and deletion of a node can be done efficiently using a max heap structure. But before we get into that, lets first start with how to create a max heap structure. Given below is the C code for the same.\r\n\r\n```\r\n#define LCHILD(x) 2 * x + 1\r\n#define RCHILD(x) 2 * x + 2\r\n#define PARENT(x) (x - 1) / 2\r\n\r\ntypedef struct node {\r\n    int data ;\r\n} node ;\r\n\r\ntypedef struct maxHeap {\r\n    int size ;\r\n    node *elem ;\r\n} maxHeap ;\r\n```\r\n\r\nIn the above code, we are creating two structures, one to represent a node and other to represent the entire max heap. The node structure has only a single member to hold the data. The maxHeap structure has two members - one to hold the total size of the max heap at any time, and the other is a pointer to the heap.\r\n\r\nThough the heap can be implemented using various child and parent pointers, its easier to use a dynamic array. Since in C array indexing begins at index 0, given a node at index i, its left child shall be at (2 * i + 1) and right child shall be at (2 * i + 2). Also, given a node at index i, its parent node shall be at index x / 2.\r\n\r\nSince the max heap can be growing dynamically, we shall be using a dynamic array which shall grow and shrink its size as required.\r\n\r\nWe also need an initializor function that shall initialize the data members of the max heap with default values.\r\n\r\n```\r\nmaxHeap initMaxHeap(int size) {\r\n    maxHeap hp ;\r\n    hp.size = 0 ;\r\n    return hp ;\r\n}\r\n```\r\nWe are creating a variale of type maxHeap and setting its size variable to 0, and returning the maxHeap variable back. So in the main function, you can have something like,\r\n\r\n```\r\nmaxHeap hp = initMaxHeap() ;\r\n```\r\n\r\n###Insertion\r\nAt best case, it takes only O(1) time to insert a node into max heap. But at worst case, the new node may be greater than all nodes in the heap, that it needs to be compared with log(n) elements at most to be put into the root node position. So insertion operation is normally considered as an O(logn) operation. Given below is the C code for the same.\r\n\r\n```\r\nvoid insertNode(maxHeap *hp, int data) {\r\n    // allocating space\r\n    if(hp->size) {\r\n        hp->elem = realloc(hp->elem, (size + 1) * sizeof(node)) ;\r\n    } else {\r\n        hp->elem = malloc(sizeof(node)) ;\r\n    }\r\n\r\n    // initializing the node with value\r\n    node nd ;\r\n    nd.data = data ;\r\n\r\n    // Positioning the node at the right position in the max heap\r\n    int i = (hp->size)++ ;\r\n    while(i && nd.data > hp->elem[PARENT(i)].data) {\r\n        hp->elem[i] = hp->elem[PARENT(i)] ;\r\n        i = PARENT(i) ;\r\n    }\r\n    hp->elem[i] = nd ;\r\n}\r\n```\r\n\r\nIn first part of insertNode() function, we allocate space for one node. On its first iteration, size variable is zero, and hence call to malloc() function is performed. Henceforth, all calls shall go to realloc() function which shall increase the memory to allocate one more node in the max heap.\r\n\r\nIn second part of insertNode() function, we simply create a node variable and initialize it with data that we need to store in the node.\r\n\r\nIn last part of insertNode() function, we shall find the correct position for the new node in max heap structure. We consider the new memory space created. We shall compare value of last node with the new node value. If its less, we shall move it to the new memory location. We shall now check its parent node, and compare it with new node. If its less, we shall move it to old position of last node. It will continue until we find a node which has value higher than the new node, and place the new node as a child node of that node.\r\n\r\n###Deletion\r\n\r\nDeletion operation is quite different from insertion operation. In each deletion operation, we shall delete the maximum element from max heap, ie, we shall always delete the root node in each deletion operation, and place the last node in root node position. Since we are placing a leaf node in root node, its guaranteed that heap property shall be violated. We shall then call a special function called heapify() function recursively to make sure that heap property is satisfied.\r\n\r\n```\r\nvoid swap(node *n1, node *n2) {\r\n    node temp = *n1 ;\r\n    *n1 = *n2 ;\r\n    *n2 = temp ;\r\n}\r\n```\r\n\r\n```\r\nvoid heapify(maxHeap *hp, int i) {\r\n    int largest = (LCHILD(i) < hp->size && hp->elem[LCHILD(i)].data > hp->elem[i].data) ? LCHILD(i) : i ;\r\n    if(RCHILD(i) < hp->size && hp->elem[RCHILD(i)].data > hp->elem[largest].data) {\r\n        largest = RCHILD(i) ;\r\n    }\r\n    if(largest != i) {\r\n        swap(&(hp->elem[i]), &(hp->elem[largest])) ;\r\n        heapify(hp, largest) ;\r\n    }\r\n}\r\n```\r\n\r\n```\r\nvoid deleteNode(maxHeap *hp) {\r\n    if(hp->size) {\r\n        printf(\"Deleting node %d\\n\\n\", hp->elem[0].data) ;\r\n        hp->elem[0] = hp->elem[--(hp->size)] ;\r\n        hp->elem = realloc(hp->elem, hp->size * sizeof(node)) ;\r\n        heapify(hp, 0) ;\r\n    } else {\r\n        printf(\"\\nMax Heap is empty!\\n\") ;\r\n        free(hp->elem) ;\r\n    }\r\n}\r\n```\r\n\r\nIn deleteNode() function, last node is placed at root node position, heap size decremented by 1, and memory of max heap reduced by one node. Heapify() function shall then be called.\r\n\r\nIn heapify() function, given a node at index i, we shall compare all the three nodes (parent, left and right child), and find the largest node of the three. If its not the parent node, then heap property is violated. Swap parent node with largest node, and call heapify() function until heap property is satisfied.\r\n\r\n###BuildMaxHeap\r\n\r\nGiven an array of n numbers, we can call the insertNode() function n times to create the max heap. Since each call to insertNode() can take upto O(logn) time, we need a maximum of O(nlogn) time to create the entire max heap. But instead of following such an approach, we can follow a relatively better buildMaxHeap() function that requires only O(n) time.\r\n\r\n```\r\nvoid buildMaxHeap(maxHeap *hp, int *arr, int size) {\r\n    int i ;\r\n\r\n    // Insertion into the heap without violating the shape property\r\n    for(i = 0; i < size; i++) {\r\n        if(hp->size) {\r\n            hp->elem = realloc(hp->elem, (hp->size + 1) * sizeof(node)) ;\r\n        } else {\r\n            hp->elem = malloc(sizeof(node)) ;\r\n        }\r\n        node nd ;\r\n        nd.data = arr[i] ;\r\n        hp->elem[(hp->size)++] = nd ;\r\n    }\r\n\r\n    // Making sure that heap property is also satisfied\r\n    for(i = (hp->size - 1) / 2; i >= 0; i--) {\r\n        heapify(hp, i) ;\r\n    }\r\n}\r\n```\r\n\r\nIn first step, we insert all elements from the array into the max heap without bothering about heap property. Since the heap is built using array structure, shape property is never violated.\r\n\r\nIn last step, we shall determine the last parent in the heap and call heapify() function on that parent node, until heap property is satisfied for that node. We shall then work back by calling heapify() function on each of those parent nodes, until we reach root node, by which time, heap property shall be satisfied.\r\n\r\n###Traversal\r\n\r\nThere are mainly two types of traversals possible on a max heap - depth first traversal and breadth first (level order) traversal. \r\n\r\nIn depth first traversal, we visit the nodes depth-wise, meaning that we go deeper and deeper into childrens of a left sibling before covering the right sibling. There are mainly three depth first traversals possible - inorder, preorder and postorder traversal.\r\n\r\n\r\n####Inorder Traversal\r\n```\r\nvoid inorderTraversal(maxHeap *hp, int i) {\r\n    if(LCHILD(i) < hp->size) {\r\n        inorderTraversal(hp, LCHILD(i)) ;\r\n    }\r\n    printf(\"%d \", hp->elem[i].data) ;\r\n    if(RCHILD(i) < hp->size) {\r\n        inorderTraversal(hp, RCHILD(i)) ;\r\n    }\r\n}\r\n```\r\n\r\nIn the above function, we check whether left child of a node at index i exists in the heap. If yes, we call the inorderTraveral() function on the left child. We now display value of the node at index i. Then we check whether right child of a node at index i exists in the heap. If yes, we call inorderTraversal() on the right child. This shall continue until we traverse the whole max heap.\r\n\r\n####Preorder Traversal\r\n```\r\nvoid preorderTraversal(maxHeap *hp, int i) {\r\n    if(LCHILD(i) < hp->size) {\r\n        preorderTraversal(hp, LCHILD(i)) ;\r\n    }\r\n    if(RCHILD(i) < hp->size) {\r\n        preorderTraversal(hp, RCHILD(i)) ;\r\n    }\r\n    printf(\"%d \", hp->elem[i].data) ;\r\n}\r\n```\r\n\r\nIn the above function, we check whether left child of the node at index i exists. If yes, we call preorderTraversal() on the left child. We then check whether right of the node exists. If yes, we call preorderTraversal() on the right child. we then display the value of the node at index i. We can see that code for preorderTraversal() and inorderTraversal() are quite similar and shall be similar to postorderTraversal() function. The only difference is the order in which the recursive functions are called.\r\n\r\n####Postorder Traversal\r\n```\r\nvoid postorderTraversal(maxHeap *hp, int i) {\r\n    printf(\"%d \", hp->elem[i].data) ;\r\n    if(LCHILD(i) < hp->size) {\r\n        postOrderTraversal(hp, LCHILD(i)) ;\r\n    }\r\n    if(RCHILD(i) < hp->size) {\r\n        postorderTraversal(hp, RCHILD(i)) ;\r\n    }\r\n}\r\n```\r\n\r\nIn postOrderTraversal() function, we display the value of the node at index 1, and recursively call the function, first on the left child and then on the right child, until we traverse the whole max heap.\r\n\r\n\r\n####Levelorder Traversal\r\n```\r\nvoid levelOrderTraversal(maxHeap *hp) {\r\n    int i ;\r\n    for(i = 0; i < hp->size; i++) {\r\n        printf(\"%d \", hp->elem[i].data) ;\r\n    }\r\n}\r\n```\r\n\r\nImplementing level order traversal is quite simple, as we are using the array implementation. All we need to do is to traverse through the whole array from index 0 to (hp->size - 1) to get the level order traversal.\r\n\r\n***\r\n\r\n#Applications of Max Heap<br/><br />\r\nAs you are already aware by now, when we delete an element from the max heap, we always get the maximum valued node from the max heap, which means that we can access the maximum valued node in O(1) time. So if you need a quick access to the largest value element, you can go for max heap implementation.\r\n\r\nMax heaps can be used to implement priority queues. In a priority queue, rather than using the value of a node, we are using priority of the node to position it in the max heap. Priority queues are used heavily in job schedulers.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}